# 1 OOP特征一：封装

## 1.1 封装的作用

1. 高内聚，低耦合
2. 提高代码的可维护性
3. 提高代码的安全性

## 1.2 封装的实现

- Java中通过将数据声明为私有的(private)
- 再提供公共的（public）
  方法：getXxx()和setXxx()实现对该属性的操作

# 2 OOP特征二：继承

## 2.1 继承的定义

- 子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为
- 子类可以直接访问父类中的非私有的属性和行为

## 2.2 继承的作用

- 继承的出现减少了代码冗余，提高了代码的复用性
- 继承的出现，更有利于功能的扩展
- 继承的出现让类与类之间产生了关系，提供了多态的前提

## 2.3 继承的语法格式

```java
class 子类名 extends 父类名 {
    ...
}
```

## 2.4 继承的特点

- Java中类只支持单继承
- Java中可以多层继承（继承体系）

## 2.5 继承的注意事项

- 子类不能继承父类的私有成员
- 子类不能继承父类的构造方法，但是可以通过super去访问
- 不要为了部分功能而去继承

## 2.6 继承的弊端

- 让类的耦合性增强。这样某个类的改变，就会影响其他和该类相关的类

## 2.7 继承中的成员关系

### 2.7.1 成员变量

- 子类和父类中的成员变量不重名：没有影响
- 子类和父类中的成员变量重名：需要使用super关键字访问父类非私有的成员变量

### 2.7.2 成员方法

- 子类和父类中的成员方法重名：方法重写override

### 2.7.3 构造方法

- 构造方法的名字是与类名一致的，所以子类是无法继承父类构造方法的
- 构造方法的作用是初始化成员变量的，所以子类的初始化过程中，必须先执行父类的初始化动作
- 子类的构造方法中默认有一个super() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。

- **注意**：父类中如果没有无参构造方法，怎么办?
  1. 子类通过super去明确调用带参构造
  2. 子类通过this调用本身的构造，但一定去访问一个父类的构造
  3. 让父类提供无参构造

# 3 方法的重写(override)

## 3.1 要求

1. 子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表
2. 子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型
3. 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限
  - 子类不能重写父类中声明为private权限的方法
4. 子类方法抛出的异常不能大于父类被重写方法的异常

## 3.2 注意

- 子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法
- Override和Overload的区别？Overload是否可以改变返回值类型？
  1. 方法重写Override：在子类中出现和父类中一模一样的方法声明的现象
  2. 方法重载Overload：同一个类中出现的方法名相同参数列表不同的现象
  3. 方法重载能改变返回值类型，因为它和返回值类型无关

# 4 OOP特征三：多态

## 4.1 多态的体现

- 父类引用指向子类对象，又称向上转型，可以直接应用在抽象类和接口上
- Java引用变量有两个类型：**编译时类型**和**运行时类型**
  - 编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定
  - 若编译时类型和运行时类型不一致，就出现了对象的多态性
- 一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法
- 虚拟方法调用(多态情况下)：在多态情况下，将父类被子类重写的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的，所以称为**动态绑定**
  - 重载编译时就确定，就是静态绑定

## 4.2 多态的前提

1. 有继承或者实现关系
2. 有方法重写
3. 有父类或者父接口引用指向子类对象

## 4.3 多态的分类

1. 具体类多态
2. 抽象类多态
3.  接口多态

## 4.4 多态的成员访问特点

1. 成员变量：不具备多态性，只看引用变量所声明的类
2. 构造方法：子类的构造都会默认访问父类构造
3. 成员方法
   - 编译时：要查看引用变量所声明的类中是否有所调用的方法
   - 运行时：调用实际new的对象所属的类中的重写方法
4. 静态方法：不具备多态性，只看引用变量所声明的类

## 4.5 instanceof操作符

- x instanceof A：检验x是否为类A的对象，返回值为boolean型
- 否则会出现ClassCastException 异常

## 4.6 对象类型转换(Casting)

- 对Java对象的强制类型转换称为造型
- 从子类到父类的类型转换可以自动进行
- 从父类到子类的类型转换必须通过造型（强制类型转换）实现
- 无继承关系的引用类型间的转换是非法的
- 在造型前可以使用instanceof操作符测试一个对象的类型

